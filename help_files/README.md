IRC
===

***IRC (Internet Relay Chat)***
 - текстовый протокол, где клиент и сервер обмениваются сообщения в формате простыз текстовых строк; каждое сообщение заканчивается **\r\n** (CR+LF)

1. ***Формат IRC сообщений (RFC 1459)***
	[:<prefix>] <command> [<param1> <param2> ... <paramN>] [:<trailing>]

	Prefix (optional)	- начинается с :, указывает
							источник сообщения (сервер или клиент)
	Command				- сама команда
							текстовая (NICK, USER, JOIN, ...) или 
							numeric reply (001,433,461)
	Parameters			- параметры команды
							(разделены пробелами,
							макс. 15,
							не могут содержать пробелы - кроме trailing)
	Trailing			- всегда последний параметр, может 
							содержать пробелы, начинается с :
	
	**Примеры:**
		Client → Server:
		NICK tanja

		Server → Client:
		:server.com 001 tanja :Welcome to IRC!

		Client → Server:
		PRIVMSG #channel :Hello everyone!

2. ***Numeric Replies***
	
 - IRC сервер отвечает клиенту *трёхзначными* кодами (numeric replies)

	**Формат**
		:<server> <code> <target> [params] :<message>
	
	**Категории кодов**
		001-099		Connection registration, welcome messages
		200-399		Command responses
		400-599		Error messages

	**Success replies (RPL_*)**
		001 RPL_WELCOME			"Welcome to the IRC Network <nick>!<user>@<host>"
		002 RPL_YOURHOST		"Your host is <servername>, running version <ver>"
		003 RPL_CREATED			"This server was created <date>"
		004 RPL_MYINFO			"<servername> <version> <available user modes> <available channel modes>"
	
	**Error replies (ERR_*)**
		401 ERR_NOSUCHNICK				"<nickname> :No such nick/channel"
		403 ERR_NOSUCHCHANNEL			"<channel> :No such channel"
		431 ERR_NONICKNAMEGIVEN			":No nickname given"
		432 ERR_ERRONEOUSNICKNAME		"<nick> :Erroneous nickname"
		433 ERR_NICKNAMEINUSE			"<nick> :Nickname is already in use"
		461 ERR_NEEDMOREPARAMS			"<command> :Not enough parameters"
		462 ERR_ALREADYREGISTERED		":You may not reregister!"
		464 ERR_PASSWDMISMATCH			":Password incorrect"

3. ***Client Registration Flow***

    - клиент должен пройти *регистрацию* перед использованием большинства команд.

	**Последовательность**
	
	   1. PASS <password>				(опционально, если сервер требует)
	   2. NICK <nickname>
	   3. USER <username> 0 * :<realname>

	-> После успешной регистрации сервер отправляет:
		:server 001 nick :Welcome...
		:server 002 nick :Your host...
		(и т.д.)
	
	**Состояние клиента**

	  UNREGISTERED	-> (PASS sent) -> PASS_OK
					-> (NICK sent) -> NICK_OK
					-> (USER sent) -> REGISTERED ✓
	
	**ВАЖНО** - пока клиент не *REGISTERED*, он не может:

		- JOIN каналы
		- отправлять PRIVMSG
		- использовать большинство команд

4. ***Nickname Rules (RFC 1459)***

	**Допустимые символы** в nickname:
	   - Буквы: A-Z, a-z
	   - Цифры: 0-9
	   - Специальные: -, [, ], \, `, _, ^, {, |, }
	
	**Ограничения:**
       - максимум *9 символов* (в современных серверах больше, но для проекта - 9)
	   - не может начинаться с цифры или -
	   - должен быть уникальным на сервере

5. ***Channel Names Rules***

	**Формат**
	    #<channel_name>		(локальный канал)
	    &<channel_name>		(локальный, видим только на этом сервере)
	
	**Правила**
	   - Начинается с # или &
	   - Не содержит: пробелы, , (comma), \а (bell), \0
	   - Максимум *50 символов*
	   - Case-insensitive: #Channel == #channel

6. ***Message Builder Theory***

 - нужно создавать сообщения для отправки клиенту

 **Зачем нужен Message Builder?**
    *Parser* разбирает входящие сообщения (Client -> Server)
    *Builder* создает исходящие сообщения (Server -> Client)

 1. *Server replies (numeric)*
 2. *Error messages*
 3. *Command responses (from server)*

 **Задачи Builder**
   1. Формировать *numeric replies*
      - Сервер отвечает клиенту кодами (001,433,461...)
	  - Правильный формат: :<server> <code> <target> :<message>\r\n
   2. Формировать *error messages*
      - Специальный случай numeric replies (4xx,5xx)
	  - Может иметь дополнительные параметры
   3. Формировать *server responses*
      - Когда сервер пересылает сообщения между клиентами
	  - Формат: :<source> <command> <params> :<trailing>\r\n

 **Правила форматирования:**
   - всегда заканчивать **\r\n**
   - prefix (источник) начинается с :
   - trailing parameter начинается с :
   - пробелы между параметрами
   - максимум 512 символов включая \r\n
 

7. ***Command Handler***

 - создаем *диспетчер команд*, к-рый
    1. получает сырую строку от сервера
	2. парсит ее через Parser::parse()
	3. смотрит на command и вызывает нужный обработчик
	   - "PASS" -> handlePass()
	   - "NICK" -> handleNick()
	   - "USER" -> handleUser()
	4. Обработчик проверяет параметры, состояние клиента
	5. Формирует ответ через MessageBuilder
	6. Отправляет ответ клиенту через client.appendToOutBuf()

 **Состояния регистрации клиента:**
  [UNREGISTERED]  →  PASS ok  →  [AUTHENTICATED]
                                     ↓
                              NICK + USER ok
                                     ↓
                              [REGISTERED] → может использовать все команды

8. ***Команды регистрации клиента***
 
 1) ***PASS ***- Аутентификация по паролю
	
	**Назначение:**
	   - Аутентифицирует клиента на сервере с паролем
	   - Должна быть отправлена *до* NICK и USER (если сервер требует пароль)
	   - Опциональна, если сервер не требует пароль
	
	**Формат:** PASS <password>

	**Примеры:**
		Client → Server:  PASS secretpassword123
		Client → Server:  PASS mypass
	
	**Правила и проверки:**
	   1. Момент использования:
	      - можно использовать только *до завершения регистрации*
		  - если клиент уже зарегистрирован (REGISTERED) -> ERR_ALREADYREGISTERED (462)
	   2. Параметры:
	      - обязательно параметр <password>
		  - если не указан -> ERR_NEEDMOREPARAMS (461)
	   3. Проверка пароля:
	      - сравнивается с паролем сервера
		  - если совпадает -> client.setAuthenticated(true)
		  - если не совпадает -> ERR_PASSWDMISMATCH (464)
	
	**Состояние клиента после PASS:**
		UNREGISTERED + password correct -> AUTHENTICATED
	
	**ВАЖНО**
	   - PASS не завершвет регистрацию сама по себе
	   - нужны также NICK и USER для полной регистрации

 2) ***NICK ***- Установка/смена nickname
	
	**Назначение:**
	   - Устанавливает или меняет nickname клиента
	   - Nickname - это уникальный идентификатор пользователя на сервере
	
	**Формат:** NICK <nickname>

	**Примеры:**
		Client → Server:  NICK tanja
		Client → Server:  NICK alice123
	
	**Правила для nickname (RFC 1459):**
	   1. Длина:
	      - Минимум: 1 символ
		  - Максимум: 9 символов
	   2. Первый символ:
	      - Буква (A-Z, a-z)
		  - Или специальный: [ ] \  _ ^ { | }`
	   3. Остальные символы:
	      - Буквы (A-Z, a-z)
		  - Цифры (0-9)
		  - Специальные: [ ] \  _ ^ { | }`
		  - Дефис (-)
	   4. Запрещено:
	      - Начинаться с цифры
		  - Начинаться с дефиса (-)
		  - Содержать пробелы

	**Проверки и ошибки:**
	   1. Параметр не указан:
	      - если NICK без параметра -> ERR_NONICKNAMEGIVEN (431)
	   2. Неверный формат:
		  - если не соответствует правилам -> ERR_ERRONEOUSNICKNAME (432)
		  - Примеры: 123nick (начинается с цифры), nick name (пробел)
	   3. Nickname занят:
	      - если другой клиент уже использует -> ERR_NICKNAMEINUSE (433)
	
	**Поведение:**
	   - *До регистрации*: устанавливает nickname
	   - *После регистрации*: меняет nickname + отправляет уведомление:
	   		:oldnick!user@localhost NICK :newnick
	
	**Влияние на регистрацию:**
	   - Если выполнены все условия:
	   		authenticated = true (PASS ok)
			nickname != empty (NICK ok)
			username != empty (USER ok)
			-> client.setRegistered(true) + отправка RPL_WELCOME (001-004)

 3) ***USER ***- Установка username и realname
	
	**Назначение:**
	   - Устанавливает username (имя пользователя) и realname (настоящее имя)
	   - используется один раз при регистрации
	
	**Формат (RFC 1459):** USER <username> <hostname> <servername> :<realname>

	**Параметры:**
	   1. <username> - имя пользователя (обычно login)
	   2. <hostname> - имя хоста (игнорируется сервером, клиент может послать что угодно)
	   3. <servername> - имя сервера (игнорируется, обычно *)
	   4. :<realname> - настоящее имя (trailing parameter, может содержать пробелы)

	**Примеры:**
		Client → Server:  USER tanja 0 * :Tanja Bolsakova
		Client → Server:  USER alice localhost * :Alice Wonderland
		Client → Server:  USER bob 0 * :Bob
	
	**Правила и проверки:**
	   1. Момент использования:
	      - можно использовать только *до завершения регистрации*
		  - если клиент уже зарегистрирован -> ERR_ALREADYREGISTERED (462)
	   2. Параметры:
	      - нужно минимум 3 параметра + trailing
		  - если меньше -> ERR_NEEDMOREPARAMS (461)
	   3. Что извлекается:
	      - username = params[0]
	      - realname = trailing
		  - params[1] и params[2] игнорируются (hostname, servername)
	
	**Влияние на регистрацию:**
	   - После успешной команды USER проверяется:
	   		authenticated = true (PASS ok)
			nickname != empty (NICK ok)
			username != empty (USER ok)
			-> client.setRegistered(true) + отправка RPL_WELCOME (001-004)

 4) ***PING/PONG ***- Keepalive механизм
	
	**Назначение:**
	   - Проверка активности соединения (keepalive)
	   - измерение задержки (latency)
	   - предотвращение таймаутов
	
	**Формат:** PING <token> или PING :<token>

	**Примеры:**
		Client → Server:  PING :test123
		Server → Client:  :ircserv PONG ircserv :test123

		Client → Server:  PING localhost
		Server → Client:  :ircserv PONG ircserv :localhost
	
	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет -> ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должен быть указан token (в params или trailing)
		  - если нет -> можно использовать имя сервера по умолчанию
	   3. Ответ PONG:
	      - формат: :<server> PONG <server> :<token>
	      - Token должен совпадать с тем, что прислал клиент
	
	**Алгоритм обработки:**
	   1. Проверить: client.isRegistered() → если нет, ERR_NOTREGISTERED
	   2. Извлечь token из params[0] или trailing
	   3. Если token пустой → использовать server_name
	   4. Построить ответ: MessageBuilder::buildCommand(server_name, "PONG", {server_name}, token)
	   5. Отправить клиенту

 5) ***PRIVMSG ***- Отправка сообщений
	
	**Назначение:**
	   - Отправка личных сообщений пользователю
	   - отправка сообщений на канал
	
	**Формат:** PRIVMSG <target> :<message>

	**Параметры:**
	   1. <target> - nickname пользователя или #channel
	   2. <message> - текст сообщения (trailing parameter)

	**Примеры:**
	   # Личное сообщение пользователю
	   Client → Server:  PRIVMSG alice :Hello Alice!
	   Server → alice:   :tanja!user@localhost PRIVMSG alice :Hello Alice!

	   # Сообщение на канал
	   Client → Server:  PRIVMSG #general :Hi everyone!
	   Server → #general: :tanja!user@localhost PRIVMSG #general :Hi everyone!
						(всем участникам канала кроме tanja)
	
	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет -> ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должен быть указан target
		  - если нет -> ERR_NORECIPIENT (411)
	      - должен быть текст сообщения (trailing)
		  - если нет -> ERR_NOTEXTTOSEND (412)
	   3. Если target = nickname:
	      - проверить, существует ли пользователь
	      - если нет -> ERR_NOSUCHNICK (401)
		  - отправить сообщение только этому пользователю
	   4. Если target = #channel:
	      - проверить, существует ли канал
	      - если нет -> ERR_NOSUCHCHANNEL (403)
	      - проверить, состоит ли отправитель на канале
	      - если нет -> ERR_CANNOTSENDTOCHAN (404)
		  - отправить сообщение всем участникам канала *кроме отправителя*
	
	**Формат пересылаемого сообщения:**
	   :<sender_nick>!<sender_user>@localhost PRIVMSG <target> :<message>
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие target и message
	   3. Определить тип target:
	      - если начинается с # -> канал
		  - иначе -> пользователь
	   4. Для пользователя:
	      - найти клиента по nickname
		  - построить сообщение с prefix отправителя
		  - отправить получателю
	   5. Для канала:
	      - проверить существование канала
		  - проверить членство отправителя
		  - отправить всем участникам кроме отправителя

 6) ***JOIN ***- Присоединение к каналу
	
	**Назначение:**
	   - Присоединиться к существующему каналу
	   - Создать новый канал (если не существует)
	
	**Формат:** JOIN <channel> [key] или 
	            JOIN <channel1>,<channel2>,... [key1,key2,...]

	**Примеры:**
	   # Присоединение к каналу без ключа
	   Client → Server:  JOIN #general

	   # Присоединение с ключом (password)
	   Client → Server:  JOIN #private secretkey

	   # Присоединение к нескольким каналам
	   Client → Server:  JOIN #general,#random
	
	**Правила для имени канала:**
	   1. Формат:
	      - начинается с # (channel) или & (local channel)
		  - максимум 50 символов
		  - не содержит: пробелы, запятые (,), control+G (\a)
	   2. Case-insensitive:
	      - #Channel == #channel == #CHANNEL
	
	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет -> ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должно быть указано имя канала
		  - если нет -> ERR_NEEDMOREPARAMS (461)
	   3. Режимы канала (modes):
	      # Mode +i (invite-only)
		     - можно войти только по приглашению
		     - если нет приглашения -> ERR_INVITEONLYCHAN (473)
	      # Mode +k (channel key)
		     - требуется правильный ключ
		     - если ключ не указан или неверный -> ERR_BADCHANNELKEY (475)
	      # Mode +l (user limit)
		     - ограничение количества пользователей
		     - если канал полон -> ERR_CHANNELISFULL (471)
	   4. Создание канала:
	      - если канал не существует -> создается новый
	      - первый участник становится оператором (mode +o)
	
	**Что происходт при успешном JOIN:**
	   1. Клиент добавляется в список участников канала
	   2. Клиенту отправлется подтверждение:
	   		:nick!user@localhost JOIN :#channel
	   3. Клиенту отправляется список участников (RPL_NAMREPLY + RPL_ENDOFNAMES)
	   4. Если есть topic -> отправляется RPL_TOPIC
	   5. Всем остальным участникам отправляется уведомление о входе:
	   		:nick!user@localhost JOIN :#channel
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметра channel
	   3. Извлечь имя канала и ключ (если есть)
	   4. Проверить валидность имени канала
	   5. Найти или создать канал:
	      - если канал не существует -> создать, сделать клиента оператором
		  - если существует -> проверить режимы (+i, +k, +l)
	   6. Добавить клиента в канал
	   7. Отправить подтверждение клиенту
	   8. Отправить уведомление всем участникам канала
	   9. Отправить список участников (NAMES)
	   10. Отправить topic (если не установлен)

 7) ***PART ***- Выход из канала
	
	**Назначение:**
	   - Покинуть канал
	   - Опционально оставить прощальное сообщение
	
	**Формат:** PART <channel> [:<reason>] или 
	            PART <channel1>,<channel2>,... [:<reason>]

	**Примеры:**
	   # Выход без сообщения
	   Client → Server:  PART #general

	   # Выход с сообщением
	   Client → Server:  PART #general :Goodbye everyone!

	   # Выход из нескольких каналов
	   Client → Server:  PART #general,#random :Leaving

	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет -> ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должно быть указано имя канала
		  - если нет -> ERR_NEEDMOREPARAMS (461)
	   3. Существование канала:
	      - канал долдене существовать
		  - если нет -> ERR_NOSUCHCHANNEL (403)
	   4. Членство на канале:
	      - клиент должен состоять на канале
		  - если нет -> ERR_NOTONCHANNEL (442)
	
	**Что происходт при успешном PART:**
	   1. Всем участникам канала (включая отправителя) отправляется:
	   		:nick!user@localhost PART #channel :reason
		  или без reason:
		    :nick!user@localhost PART #channel
	   2. Клиент удаляется из списка участником канала
	   3. Если канал становится пустым -> канал удаляется
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметра channel
	   3. Извлечь имя канала и reason (если есть)
	   4. Проверить существование канала
	   5. Проверить членство клиента на канале
	   6. Построить сообщение PART с prefix клиента
	   7. Отправить всем участникам канала (включая отправителя)
	   8. Удалить клиента из канала
	   9. Если канал пустой -> удалить канал

 8) ***QUIT ***- Отключение от сервера
	
	**Назначение:**
	   - Корректное отключение клиента от сервера
	   - Уведомление всех участников общих каналов
	
	**Формат:** QUIT [:<reason>]

	**Примеры:**
	   # Выход без сообщения
	   Client → Server:  QUIT

	   # Выход с сообщением
	   Client → Server:  QUIT :Going to sleep

	   # Выход с длинным сообщением
	   Client → Server:  QUIT :Thanks for the chat, see you tomorrow!

	**Правила и проверки:**
	   1. Регистрация:
	      - можно использовать даже без регистрации
		  - клиент будет отключен в любом случае
	   2. Параметры:
	      - Reason опционален
		  - если не указан -> используется сообщение по умолчанию: "Client exited"
	
	**Что происходт при QUIT:**
	   1. Всем участникам канала, где состоит клиент, отправляется:
	   		:nick!user@localhost QUIT :reason
	   2. Клиент удаляется из всех каналов
	   3. Пустые каналы удаляются
	   4. Соединение закрывается (close socket)
	   5. Клиент удаляется из списка подключенных клиентов сервера
	
	**Алгоритм обработки:**
	   1. Извлечь reason (если есть) или использовать "Client exited"
	   2. Построить сообщение QUIT с prefix клиента
	   3. Для каждого канала, где состоит клиент:
	      - отправить сообщение QUIT всем участникам канала
		  - удалить клиента из канала
		  - если канал пустой -> удалть канал
	   4. Закрыть соединение (socket)
	   5. Удалить клиента из server.m_clients
	
	**ВАЖНО:**
	   - QUIT отличается от простого закрытия соединения (disconnect)
	   - При QUIT отправляются уведомления, при disconnect - ERROR сообщение

 9) ***KICK ***- Удаление пользователя с канала
	
	**Назначение:**
	   - Принудительное удаление пользователя с канала
	   - Доступно только операторам канала
	
	**Формат:** KICK <channel> <user> [:<reason>]

	**Примеры:**
	   # Kick без причины
	   Operator → Server:  KICK #general alice

	   # Kick с причиной
	   Operator → Server:  KICK #general bob :Bad behavior

	   # Kick с длинной причиной
	   Operator → Server:  KICK #general charlie :Spamming and flooding the channel

	**Правила и проверки:**
	   1. Регистрация:
	      - можно использовать даже без регистрации
		  - если нет → ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должны быть указаны channel и user
		  - если нет → ERR_NEEDMOREPARAMS (461)
	   3. Существование канала:
	      - канал должен существовать
		  - если нет → ERR_NOSUCHCHANNEL (403)
	   4. Членство на канале:
	      - отправитель (kicker) должен состоять на канале
		  - если нет → ERR_NOTONCHANNEL (442)
	   5. Права оператора:
	      - Отправитель должен быть оператором канала (mode +o)
		  - если нет → ERR_CHANOPRIVSNEEDED (482)
	   6. Существование kicked пользователя:
	      - kicked пользователь должен состоять на канале
		  - если нет → ERR_USERNOTINCHANNEL (441)
	
	**Что происходт при успешном KICK:**
	   1. Всем участникам канала отправляется:
	   		:operator_nick!user@localhost KICK #channel kicked_nick :reason
		  или без reason:
		    :operator_nick!user@localhost KICK #channel kicked_nick
	   2. Kicked пользователь удаляется из канала
	   3. Если канал становится пустым -> канал удаляется
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметров (channel, user)
	   3. Извлечь channel, kicked_nick, reason (если есть)
	   4. Проверить существование канала
	   5. Проверить членство клиента на канале
	   6. Проверить права оператора отправителя
	   7. Найти kicked пользователя на канале
	   8. Построить сообщение KICK с prefix отправителя
	   9. Отправить всем участникам канала
	   10. Удалить kicked пользователя из канала
	   11. Если канал пустой -> удалить канал

 10) ***INVITE ***- Приглашение на канал
	
	**Назначение:**
	   - Пригласить пользователя на канал
	   - Обязательно для каналов с режимом +i (invite-only)
	
	**Формат:** INVITE <nickname> <channel>

	**Примеры:**
	   Client → Server:  INVITE alice #private
	   Client → Server:  INVITE bob #secret

	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет → ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должны быть указаны nickname и channel
		  - если нет → ERR_NEEDMOREPARAMS (461)
	   3. Существование канала:
	      - канал должен существовать
		  - если нет → ERR_NOSUCHCHANNEL (403)
	   4. Членство на канале:
	      - отправитель должен состоять на канале
		  - если нет → ERR_NOTONCHANNEL (442)
	   5. Права для приглашения:
	      - если канал имеет mode +i (invite-only) → только операторы могут приглашать
		  - если нет mode +i → любой участник может приглашать
		  - если не оператор на +i канале → ERR_CHANOPRIVSNEEDED (482)
	   6. Существование приглашаемого:
	      - Приглашаемый пользователь должен существовать на сервере
		  - если нет → ERR_NOSUCHNICK (401)
	   7. Проверка на повтор:
	      - если приглашаемый уже на канале → ERR_USERONCHANNEL (443)
	
	**Что происходт при успешном INVITE:**
	   1. Приглашаемому пользователю отправляется:
	   		:inviter_nick!user@localhost INVITE invited_nick :#channel
	   2. Отправителю отправляется подтверждение (RPL_INVITING 341):
	   		:ircserv 341 inviter_nick invited_nick #channel
	   3. Приглашение сохраняется в списке приглашений канала (для mode +i)
	   4. Приглашенный пользователь может теперь войти на канал (даже если +i)
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметров (nickname, channel)
	   3. Извлечь invited_nick и channel_name
	   4. Проверить существование канала
	   5. Проверить членство отправителя на канале
	   6. Проверить существование приглашаемого пользователя
	   7. Проверить, не состоит ли уже приглашаемый на канале
	   8. Если канал +i → проверить права оператора отправителя
	   9. Добавить приглашение в список (для +i каналов)
	   10. Отправить INVITE приглашаемому
	   11. Отправить RPL_INVITING отправителю

 11) ***TOPIC ***- Просмотр/установка топика канала
	
	**Назначение:**
	   - Просмотреть текущий топик канала
	   - Установить новый топик канала
	
	**Формат:** TOPIC <channel>              # Просмотр топика
	            TOPIC <channel> :<new_topic> # Установка топика
	            TOPIC <channel> :            # Удаление топика

	**Примеры:**
	   # Просмотр топика
	   Client → Server:  TOPIC #general
	   Server → Client:  :ircserv 332 nick #general :Welcome to general chat!

	   # Установка топика
	   Client → Server:  TOPIC #general :New topic here
	   Server → all:     :nick!user@localhost TOPIC #general :New topic here

	   # Удаление топика
	   Client → Server:  TOPIC #general :
	   Server → all:     :nick!user@localhost TOPIC #general :

	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет → ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должен быть указан канал
		  - если нет → ERR_NEEDMOREPARAMS (461)
	   3. Существование канала:
	      - канал должен существовать
		  - если нет → ERR_NOSUCHCHANNEL (403)
	   4. Членство на канале:
	      - отправитель должен состоять на канале
		  - если нет → ERR_NOTONCHANNEL (442)
	   5. Права на изменение топика (mode +t):
	      - если канал имеет mode +t → только операторы могут менять топик
		  - если клиент не оператор → ERR_CHANOPRIVSNEEDED (482)
		  - если нет mode +t → любой участник может менять топик
	
	**Поведение:**
	   a) Просмотр топика (нет trailing параметра):
	      - если топик установлен → RPL_TOPIC (332):
		    :ircserv 332 nick #channel :Topic text
	      - если топик не установлен → RPL_NOTOPIC (331):
		    :ircserv 331 nick #channel :No topic is set
	   b) Установка топика (есть trailing параметр):
	      - топик сохраняется для канала
	      - всем участникам канала отправляется:
		    :nick!user@localhost TOPIC #channel :New topic
	   c) Удаление топика (trailing = пустая строка):
	      - топик удаляется
	      - всем участникам отправляется:
		    :nick!user@localhost TOPIC #channel :
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметра channel
	   3. Проверить существование канала
	   4. Проверить членство клиента на канале
	   5. Если trailing пустой (просмотр):
	      - если топик есть → отправить RPL_TOPIC
	      - если топика нет → отправить RPL_NOTOPIC
	   6. Если trailing есть (установка/удаление):
	      - если mode +t → проверить права оператора
	      - установить новый топик (или удалить если пустой)
	      - отправить уведомление всем участникам канала

 12) ***MODE ***- Управление режимами канала
	
	**Назначение:**
	   - Просмотреть текущие режимы канала
	   - Установить/снять режимы канала
	   - Выдать/забрать права оператора
	
	**Формат:** MODE <channel>                    # Просмотр режимов
	            MODE <channel> +<modes> [args]    # Установка режимов
	            MODE <channel> -<modes> [args]    # Снятие режимов

	**Режимы канала (channel modes):**
	   1. i (invite-only)
	      - канал доступен только по приглашению
		  - формат: MODE #channel +i или MODE #channel -i
	   2. t (topic protection)
	      - только операторы могут менять топик
		  - формат: MODE #channel +t или MODE #channel -t
	   3. k (channel key / password)
	      - требуется ключ для входа на канал
		  - формат: MODE #channel +k <key> или MODE #channel -k
	      - при установке требуется аргумент (ключ)
	   4. o (channel operator)
	      - выдать/забрать права оператора
		  - Формат: MODE #channel +o <nick> или MODE #channel -o <nick>
	      - требуется аргумент (nickname)
	   5. l (user limit)
	      - ограничение количества пользователей на канале
		  - формат: MODE #channel +l <limit> или MODE #channel -l
	      - при установке требуется аргумент (число)

	**Примеры:**
	   # Просмотр режимов
	   Client → Server:  MODE #general
	   Server → Client:  :ircserv 324 nick #general +nt

	   # Установка invite-only
	   Client → Server:  MODE #general +i
	   Server → all:     :nick!user@localhost MODE #general +i

	   # Установка ключа
	   Client → Server:  MODE #general +k secretpass
	   Server → all:     :nick!user@localhost MODE #general +k secretpass

	   # Выдача прав оператора
	   Client → Server:  MODE #general +o alice
	   Server → all:     :nick!user@localhost MODE #general +o alice

	   # Установка лимита пользователей
	   Client → Server:  MODE #general +l 50
	   Server → all:     :nick!user@localhost MODE #general +l 50

	   # Комбинация режимов
	   Client → Server:  MODE #general +nt
	   Server → all:     :nick!user@localhost MODE #general +nt

	   # Снятие режимов
	   Client → Server:  MODE #general -i
	   Server → all:     :nick!user@localhost MODE #general -i

	**Правила и проверки:**
	   1. Регистрация:
	      - клиент должен быть зарегистрирован
		  - если нет → ERR_NOTREGISTERED (451)
	   2. Параметры:
	      - должен быть указан канал
		  - если нет → ERR_NEEDMOREPARAMS (461)
	   3. Существование канала:
	      - канал должен существовать
		  - если нет → ERR_NOSUCHCHANNEL (403)
	   4. Членство на канале:
	      - отправитель должен состоять на канале
		  - если нет → ERR_NOTONCHANNEL (442)
	   5. Права оператора:
	      - Для изменения режимов нужны права оператора
		  - если нет → ERR_CHANOPRIVSNEEDED (482)
	   6. Аргументы для режимов:
	      - +k требует ключ: MODE #channel +k key
		  - +o/-o требует nickname: MODE #channel +o alice
		  - +l требует число: MODE #channel +l 50
		  - если аргумент отсутствует → ERR_NEEDMOREPARAMS (461)
	   7. Валидация аргументов:
	      - Для +o/-o: пользователь должен существовать на канале
		    + если нет → ERR_USERNOTINCHANNEL (441)
		  - Для +l: аргумент должен быть положительным числом
		    + если не число → игнорировать или ошибка
	
	**Поведение:**
	   a) Просмотр режимов (только channel без modes):
	      - Отправить RPL_CHANNELMODEIS (324):
		    :ircserv 324 nick #channel +modes [mode_args]
	      - Пример: :ircserv 324 nick #general +ntk secretkey
	   b) Установка режимов (+):
	      - применить изменения к каналу
	      - всем участникам отправить:
		    :nick!user@localhost MODE #channel +modes [args]
	   c) Снятие режимов (-):
	      - убрать режимы с канала
	      - всем участникам отправить:
		    :nick!user@localhost MODE #channel -modes [args]
	
	**Примеры обработки сложных MODE:**
	   # Несколько режимов одновременно
	   MODE #chan +nt            → устанавливает +n и +t
	   MODE #chan -it            → снимает -i и -t
	   MODE #chan +o-o alice bob → выдает +o alice и забирает -o bob

	   # С аргументами
	   MODE #chan +kl secret 10  → key=secret, limit=10
	   MODE #chan +oo alice bob  → оба становятся ops
	   MODE #chan -o+o alice bob → alice теряет op, bob получает op
	
	**Алгоритм обработки:**
	   1. Проверить регистрацию
	   2. Проверить наличие параметра channel
	   3. Проверить существование канала
	   4. Проверить членство клиента на канале
	   5. Если нет mode_string (просмотр):
	      - построить строку текущих режимов канала
	      - отправить RPL_CHANNELMODEIS
	   6. Если есть mode_string (изменение):
	      - проверить права оператора
	      - парсить mode_string (+i-t+k и т.д.)
	      - для каждого режима:
		    a) если +i/-i → установить/снять invite-only
		    b) если +t/-t → установить/снять topic protection
		    c) если +k → проверить аргумент, установить ключ
		    d) если -k → удалить ключ
		    e) если +o/-o → проверить nickname, выдать/забрать operator
		    f) если +l → проверить число, установить лимит
		    g) если -l → убрать лимит
	      - построить сообщение MODE с изменениями
	      - отправить всем участникам канала
	
	**ВАЖНО:**
	   1. Порядок обработки: слева направо
	    	MODE #chan +i-t+k secret → сначала +i, потом -t, потом +k
	   2. Аргументы соответствуют режимам:
	    	MODE #chan +ok alice secret
			arg[0] = alice (для +o)
			arg[1] = secret (для +k)
	   3. Неизвестные режимы игнорируются:
	    	MODE #chan +xyz → неизвестные x,y,z просто игнорируются

 13) ***DISCONNECT ***- Обработка отключения клиента
	
	**Назначение:**
	   - Корректная обработка неожиданного отключения (не QUIT)
	   - Очистка ресурсов и уведомление участников каналов

	**Когда происходит disconnect:**
	   - Клиент закрыл соединение без отправки QUIT
	   - Потеря сетевого соединения
	   - Timeout
	   - poll() вернул POLLERR, POLLHUP, или POLLNVAL
	
	**Что должен делать сервер:**
	   1. Определить отключение:
	      - recv() вернул 0 → клиент закрыл соединение
		  - poll() вернул POLLHUP → соединение потеряно
		  - poll() вернул POLLERR → ошибка сокета
	   2. Уведомить участников каналов:
	      - Отправить всем на общих каналах:
			   ERROR :Closing Link: nickname (Client exited) или
			   :nick!user@localhost QUIT :Client disconnected
	   3. Очистить каналы:
	      - удалить клиента из всех каналов
		  - удалить пустые каналы
	   4. Закрыть соединение:
	      - close(client_fd)
	   5. Удалить клиента:
	      - Удалить из server.m_clients

	**Алгоритм обработки:**
	   1. Построить сообщение QUIT: "Client disconnected"
	   2. Для каждого канала, где состоит клиент:
	      - Отправить QUIT всем участникам
	      - Удалить клиента из канала
	      - Если канал пустой → удалить канал
	   3. Закрыть socket: close(fd)
	   4. Удалить клиента из server.m_clients
	   5. Логировать: "Client fd X disconnected"
	
	**ВАЖНО:**
	   1. Disconnect обрабатывается в Server::disconnectClient(int fd)
	   2. Не путать с командой QUIT (клиент сам отправляет)
	   3. При disconnect не ждем подтверждения от клиента








**Необходимость использования статических методов**
	1. Нужно ли парсеру состояние?

		Что такое "состояние" парсера?

		Состояние - это данные, к-рые парсер должен помнить между вызовами. Например:
			- настройки парсинга
			- история предыдущих сообщений
			- контекст текущей сессии
			- счетчики или буферы
		
		IRC парсер - это "чистая" функция

		Каждое IRC сообщение - это независимая единица
		"NICK alice\r\n"			-> Полностью самостоятельное
		"JOIN #channel\r\n"			-> Не зависит от предыдущего
		"PRIVMSG bob :Hi!\r\n"		-> Не требует контекста

		Парсинг - это простое преобразование:
			Строка -> Структурированные данные
			Input -> Output
			Без побочных эффектов
	
	2. Почему статические методы идеальны для IRC?

		- Незаисимость сообщений (каждое сообщение парсится отдельно)
		- Нет конфигурации (IRC протокол имеет фиксированный формат)
		- Потокобезопасность (статические методы безопасны для многопоточности, разные клиенты могут парсить одновременно)

1. Создание структуры для хранения сообщений - Message.hpp

	- Почему std::vector<std::string> для params, а не просто std::string?
		
		Параметры - это отдельные аргументы команды, разделенные пробелами. Каждый параметр - это самостоятельная единица информации.

		- Команда MODE
		- Параметры:
			1. #channel (какой канал)
			2. +о (какой режим)
			3. tanja (на кого применить)

		Если бы мы использовали string, нам пришлось бы каждый раз парсить строку заново!
		С vector мы можем легко получить каждый параметр
			- params[0]; (получить канал -> "#channel")
			- params[1]; (получить режим -> "+o")
			- params[2]; (получить пользователя -> "tanja")
			- params.size(); (узнать количество параметров -> 3)

2. **Парсер**

	Пошаговый алгоритм парсинга:

	**Шаг 1:** Удаляем \r\n
	- они нам больше не нужны
	
	**Шаг 2:** Проверяем префикс
	- если строка начинается с :, значит есть префикс
	
	**Шаг 3:** Извлекаем команду
	- это всегда первое слово (после префикса, если он есть)
	
	**Шаг 4:** Обрабатываем параметры
	- все что осталось, разделяя обычные параметры и trailing

	1) Пишем функцию **stripCRLF()**

		**Шаг 1:** Проверяем длину
		- если меньше 2 символов, то там точно нет \r\n
		
		**Шаг 2:** Проверяем последние 2 символа
		
		**Шаг 3:** Используем substr(0, length-2) чтобы вернуть все кроме последних 2 символов
	
	2) Пишем функцию **extractPrefix()**

		**Шаг 1:** Префикс всегда начинается с :
		
		**Шаг 2:** Префикс заканчивается первым пробелом
		
		**Шаг 3:** Мы изменяем исходную строку, удаляя из нее префикс


	3) Пишем функцию **extractCommand()**

		Команда - это обязательная часть сообщения, к-рая говорит ЧТО нужно сделать. Идет сразу после префикса (если он есть) и заканчивается пробелом или концом строки

		Правила для команд:
			- Команда может быт словом: NICK, JOIN, PRIVMSG
			- числовым кодом: 001, 433, 461
			- команды-слова должны быть в верхнем регистре
			- команда не может содержать пробелы
		
		**Шаг 1:** Проверяем что строка не пустая
		- Если пустая - это ошибка протокола

		**Шаг 2:** Ищем первый пробел
		- `find(' ')` возвращает позицию пробела или `npos` если не найден

		**Шаг 3:** Извлекаем команду
		- Если пробела нет - вся строка это команда (например, просто "QUIT")
		- Если пробел есть - берем всё до пробела

		**Шаг 4:** Дополнительная проверка
		- На всякий случай проверяем что команда не пустая

5. Парсинг параметров

	В IRC есть два вида параметров:
	1. **Обычные параметры** - разделены пробелами, не могут содержать пробелы
	2. **Trailing параметр** - начинается с `:`, может содержать пробелы, всегда последний

	Примеры:
		NICK alice                      # 1 обычный параметр
		JOIN #channel                   # 1 обычный параметр  
		MODE #channel +o bob            # 3 обычных параметра
		PRIVMSG bob :Hello there!       # 1 обычный + 1 trailing
		TOPIC #channel :New topic here  # 1 обычный + 1 trailing

