IRC
===

***IRC (Internet Relay Chat)***
 - текстовый протокол, где клиент и сервер обмениваются сообщения в формате простыз текстовых строк; каждое сообщение заканчивается **\r\n** (CR+LF)

1. ***Формат IRC сообщений (RFC 1459)***
	[:<prefix>] <command> [<param1> <param2> ... <paramN>] [:<trailing>]

	Prefix (optional)	- начинается с :, указывает
							источник сообщения (сервер или клиент)
	Command				- сама команда
							текстовая (NICK, USER, JOIN, ...) или 
							numeric reply (001,433,461)
	Parameters			- параметры команды
							(разделены пробелами,
							макс. 15,
							не могут содержать пробелы - кроме trailing)
	Trailing			- всегда последний параметр, может 
							содержать пробелы, начинается с :
	
 *Примеры:*
		Client → Server:
		NICK tanja

		Server → Client:
		:server.com 001 tanja :Welcome to IRC!

		Client → Server:
		PRIVMSG #channel :Hello everyone!

2. ***Numeric Replies***
	
 - IRC сервер отвечает клиенту *трёхзначными* кодами (numeric replies)

	**Формат**
		:<server> <code> <target> [params] :<message>
	
	**Категории кодов**
		001-099		Connection registration, welcome messages
		200-399		Command responses
		400-599		Error messages

	**Success replies (RPL_*)**
		001 RPL_WELCOME			"Welcome to the IRC Network <nick>!<user>@<host>"
		002 RPL_YOURHOST		"Your host is <servername>, running version <ver>"
		003 RPL_CREATED			"This server was created <date>"
		004 RPL_MYINFO			"<servername> <version> <available user modes> <available channel modes>"
	
	**Error replies (ERR_*)**
		401 ERR_NOSUCHNICK				"<nickname> :No such nick/channel"
		403 ERR_NOSUCHCHANNEL			"<channel> :No such channel"
		431 ERR_NONICKNAMEGIVEN			":No nickname given"
		432 ERR_ERRONEOUSNICKNAME		"<nick> :Erroneous nickname"
		433 ERR_NICKNAMEINUSE			"<nick> :Nickname is already in use"
		461 ERR_NEEDMOREPARAMS			"<command> :Not enough parameters"
		462 ERR_ALREADYREGISTERED		":You may not reregister!"
		464 ERR_PASSWDMISMATCH			":Password incorrect"

3. ***Client Registration Flow***

 - клиент должен пройти *регистрацию* перед использованием большинства команд.

	**Последовательность**
	
	1. PASS <password>					(опционально, если сервер требует)
	2. NICK <nickname>
	3. USER <username> 0 * :<realname>

	-> После успешной регистрации сервер отправляет:
		:server 001 nick :Welcome...
		:server 002 nick :Your host...
		(и т.д.)
	
	**Состояние клиента**

	UNREGISTERED	-> (PASS sent) -> PASS_OK
					-> (NICK sent) -> NICK_OK
					-> (USER sent) -> REGISTERED ✓
	
	**ВАЖНО** - пока клиент не *REGISTERED*, он не может:

		- JOIN каналы
		- отправлять PRIVMSG
		- использовать большинство команд

4. ***Nickname Rules (RFC 1459)***

	**Допустимые символы** в nickname:
	   - Буквы: A-Z, a-z
	   - Цифры: 0-9
	   - Специальные: -, [, ], \, `, _, ^, {, |, }
	
	**Ограничения:**
       - максимум *9 символов* (в современных серверах больше, но для проекта - 9)
	   - не может начинаться с цифры или -
	   - должен быть уникальным на сервере

5. ***Channel Names Rules***

	**Формат**
	    #<channel_name>		(локальный канал)
	    &<channel_name>		(локальный, видим только на этом сервере)
	
	**Правила**
	   - Начинается с # или &
	   - Не содержит: пробелы, , (comma), \а (bell), \0
	   - Максимум *50 символов*
	   - Case-insensitive: #Channel == #channel

6. ***Message Builder Theory***

 - нужно создавать сообщения для отправки клиенту

 **Зачем нужен Message Builder?**
    *Parser* разбирает входящие сообщения (Client -> Server)
    *Builder* создает исходящие сообщения (Server -> Client)

 1. *Server replies (numeric)*
 2. *Error messages*
 3. *Command responses (from server)*

 **Задачи Builder**
   1. Формировать *numeric replies*
      - Сервер отвечает клиенту кодами (001,433,461...)
	  - Правильный формат: :<server> <code> <target> :<message>\r\n
   2. Формировать *error messages*
      - Специальный случай numeric replies (4xx,5xx)
	  - Может иметь дополнительные параметры
   3. Формировать *server responses*
      - Когда сервер пересылает сообщения между клиентами
	  - Формат: :<source> <command> <params> :<trailing>\r\n

 **Правила форматирования:**
   - всегда заканчивать **\r\n**
   - prefix (источник) начинается с :
   - trailing parameter начинается с :
   - пробелы между параметрами
   - максимум 512 символов включая \r\n
 

7. ***Command Handler***

 - создаем *диспетчер команд*, к-рый
    1. получает сырую строку от сервера
	2. парсит ее через Parser::parse()
	3. смотрит на command и вызывает нужный обработчик
	   - "PASS" -> handlePass()
	   - "NICK" -> handleNick()
	   - "USER" -> handleUser()
	4. Обработчик проверяет параметры, состояние клиента
	5. Формирует ответ через MessageBuilder
	6. Отправляет ответ клиенту через client.appendToOutBuf()

 **Состояния регистрации клиента:**
  [UNREGISTERED]  →  PASS ok  →  [AUTHENTICATED]
                                     ↓
                              NICK + USER ok
                                     ↓
                              [REGISTERED] → может использовать все команды


**Необходимость использования статических методов**
	1. Нужно ли парсеру состояние?

		Что такое "состояние" парсера?

		Состояние - это данные, к-рые парсер должен помнить между вызовами. Например:
			- настройки парсинга
			- история предыдущих сообщений
			- контекст текущей сессии
			- счетчики или буферы
		
		IRC парсер - это "чистая" функция

		Каждое IRC сообщение - это независимая единица
		"NICK alice\r\n"			-> Полностью самостоятельное
		"JOIN #channel\r\n"			-> Не зависит от предыдущего
		"PRIVMSG bob :Hi!\r\n"		-> Не требует контекста

		Парсинг - это простое преобразование:
			Строка -> Структурированные данные
			Input -> Output
			Без побочных эффектов
	
	2. Почему статические методы идеальны для IRC?

		- Незаисимость сообщений (каждое сообщение парсится отдельно)
		- Нет конфигурации (IRC протокол имеет фиксированный формат)
		- Потокобезопасность (статические методы безопасны для многопоточности, разные клиенты могут парсить одновременно)

1. Создание структуры для хранения сообщений - Message.hpp

	- Почему std::vector<std::string> для params, а не просто std::string?
		
		Параметры - это отдельные аргументы команды, разделенные пробелами. Каждый параметр - это самостоятельная единица информации.

		- Команда MODE
		- Параметры:
			1. #channel (какой канал)
			2. +о (какой режим)
			3. tanja (на кого применить)

		Если бы мы использовали string, нам пришлось бы каждый раз парсить строку заново!
		С vector мы можем легко получить каждый параметр
			- params[0]; (получить канал -> "#channel")
			- params[1]; (получить режим -> "+o")
			- params[2]; (получить пользователя -> "tanja")
			- params.size(); (узнать количество параметров -> 3)

2. **Парсер**

	Пошаговый алгоритм парсинга:

	**Шаг 1:** Удаляем \r\n
	- они нам больше не нужны
	
	**Шаг 2:** Проверяем префикс
	- если строка начинается с :, значит есть префикс
	
	**Шаг 3:** Извлекаем команду
	- это всегда первое слово (после префикса, если он есть)
	
	**Шаг 4:** Обрабатываем параметры
	- все что осталось, разделяя обычные параметры и trailing

	1) Пишем функцию **stripCRLF()**

		**Шаг 1:** Проверяем длину
		- если меньше 2 символов, то там точно нет \r\n
		
		**Шаг 2:** Проверяем последние 2 символа
		
		**Шаг 3:** Используем substr(0, length-2) чтобы вернуть все кроме последних 2 символов
	
	2) Пишем функцию **extractPrefix()**

		**Шаг 1:** Префикс всегда начинается с :
		
		**Шаг 2:** Префикс заканчивается первым пробелом
		
		**Шаг 3:** Мы изменяем исходную строку, удаляя из нее префикс


	3) Пишем функцию **extractCommand()**

		Команда - это обязательная часть сообщения, к-рая говорит ЧТО нужно сделать. Идет сразу после префикса (если он есть) и заканчивается пробелом или концом строки

		Правила для команд:
			- Команда может быт словом: NICK, JOIN, PRIVMSG
			- числовым кодом: 001, 433, 461
			- команды-слова должны быть в верхнем регистре
			- команда не может содержать пробелы
		
		**Шаг 1:** Проверяем что строка не пустая
		- Если пустая - это ошибка протокола

		**Шаг 2:** Ищем первый пробел
		- `find(' ')` возвращает позицию пробела или `npos` если не найден

		**Шаг 3:** Извлекаем команду
		- Если пробела нет - вся строка это команда (например, просто "QUIT")
		- Если пробел есть - берем всё до пробела

		**Шаг 4:** Дополнительная проверка
		- На всякий случай проверяем что команда не пустая

5. Парсинг параметров

	В IRC есть два вида параметров:
	1. **Обычные параметры** - разделены пробелами, не могут содержать пробелы
	2. **Trailing параметр** - начинается с `:`, может содержать пробелы, всегда последний

	Примеры:
		NICK alice                      # 1 обычный параметр
		JOIN #channel                   # 1 обычный параметр  
		MODE #channel +o bob            # 3 обычных параметра
		PRIVMSG bob :Hello there!       # 1 обычный + 1 trailing
		TOPIC #channel :New topic here  # 1 обычный + 1 trailing

